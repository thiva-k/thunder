<!doctype html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <link rel="icon" type="image/svg+xml" href="/favicon.ico" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Gate</title>

    <!-- Start of loading application configurations -->
    <script type="text/javascript" src="/config.js"></script>
    <!-- End of loading application configurations -->

    <script>
      // ====== Config ======
      const CONFIG = {
        baseDensity: 0.12, // particles per 10,000 px^2 (scales with screen size)
        maxSpeed: 0.3, // px / frame
        radius: [2.0, 3.2], // min, max radius
        linkDist: 210, // maximum distance to draw line between particles
        linkAlpha: 0.2, // base opacity of the lines
        mouseInfluence: 110, // radius of influence at mouse
        repelStrength: 0.35, // how strong the repel effect is
        attractStrength: 0.2, // alternative: set positive for attraction
        clickBurst: 120, // impulse on click
        colorParticle: "#ffffff47",
        colorLink: "#ffffff"
      };

      window.onload = function() {
        // ====== Setup canvas (DPR aware) ======
        const canvas = document.getElementById("bg");
        const ctx = canvas.getContext("2d", { alpha: true });
        let DPR = Math.max(1, Math.min(2, window.devicePixelRatio || 1)); // clamp pentru perf
        let W = 0,
          H = 0;

        function resize() {
          DPR = Math.max(1, Math.min(2, window.devicePixelRatio || 1));
          W = canvas.width = Math.floor(window.innerWidth * DPR);
          H = canvas.height = Math.floor(window.innerHeight * DPR);
          canvas.style.width = window.innerWidth + "px";
          canvas.style.height = window.innerHeight + "px";
          computeParticlesCount();
        }
        window.addEventListener("resize", resize, { passive: true });

        // ====== Particles ======
        let particles = [];
        let targetCount = 0;

        function rand(min, max) {
          return Math.random() * (max - min) + min;
        }
        function clamp(v, a, b) {
          return Math.max(a, Math.min(b, v));
        }

        class Particle {
          constructor() {
            this.reset(true);
          }
          reset(randomPos = false) {
            this.x = randomPos ? rand(0, W) : Math.random() < 0.5 ? 0 : W;
            this.y = randomPos ? rand(0, H) : rand(0, H);
            const ang = rand(0, Math.PI * 2);
            const speed = rand(0.05, CONFIG.maxSpeed);
            this.vx = Math.cos(ang) * speed;
            this.vy = Math.sin(ang) * speed;
            this.r = rand(CONFIG.radius[0], CONFIG.radius[1]) * DPR;
          }
          step(mx, my) {
            // Mouse influence (repel by default)
            if (mx !== null && my !== null) {
              const dx = this.x - mx,
                dy = this.y - my;
              const d2 = dx * dx + dy * dy;
              const r = CONFIG.mouseInfluence * DPR;
              if (d2 < r * r) {
                const d = Math.sqrt(d2) || 0.001;
                const ux = dx / d,
                  uy = dy / d;
                // Repel (positive), attract (negative)
                const strength = CONFIG.repelStrength; // sau -CONFIG.attractStrength
                this.vx += ux * strength * (1 - d / r);
                this.vy += uy * strength * (1 - d / r);
              }
            }

            // Velocity clamp
            const sp = Math.hypot(this.vx, this.vy);
            const maxSp = CONFIG.maxSpeed;
            if (sp > maxSp) {
              this.vx *= maxSp / sp;
              this.vy *= maxSp / sp;
            }

            // Move
            this.x += this.vx * DPR;
            this.y += this.vy * DPR;

            // Wrap around edges (spațiu infinit)
            if (this.x < -50) this.x = W + 50;
            if (this.x > W + 50) this.x = -50;
            if (this.y < -50) this.y = H + 50;
            if (this.y > H + 50) this.y = -50;
          }
          draw() {
            ctx.beginPath();
            ctx.arc(this.x, this.y, this.r, 0, Math.PI * 2);
            ctx.fillStyle = CONFIG.colorParticle;
            ctx.globalAlpha = 0.9;
            ctx.fill();
          }
        }

        function computeParticlesCount() {
          // scalează numărul în funcție de aria vizibilă
          const area = (W * H) / (DPR * DPR);
          const per10k = CONFIG.baseDensity; // per 10,000 px^2
          targetCount = Math.round(per10k * (area / 10000));
          // soft cap pentru mobile
          targetCount = clamp(targetCount, 40, 220);
          if (particles.length < targetCount) {
            const add = targetCount - particles.length;
            for (let i = 0; i < add; i++) particles.push(new Particle());
          } else if (particles.length > targetCount) {
            particles.length = targetCount;
          }
        }

        // ====== Mouse ======
        const mouse = { x: null, y: null, down: false };
        window.addEventListener(
          "mousemove",
          (e) => {
            mouse.x = e.clientX * DPR;
            mouse.y = e.clientY * DPR;
          },
          { passive: true }
        );
        window.addEventListener("mouseleave", () => {
          mouse.x = mouse.y = null;
        });

        window.addEventListener("mousedown", () => {
          mouse.down = true;
        });
        window.addEventListener("mouseup", () => {
          mouse.down = false;
        });

        // click = mic „burst” de energie
        window.addEventListener("click", (e) => {
          const mx = e.clientX * DPR,
            my = e.clientY * DPR;
          for (let i = 0; i < particles.length; i++) {
            const p = particles[i];
            const dx = p.x - mx,
              dy = p.y - my;
            const d2 = dx * dx + dy * dy;
            const r = CONFIG.mouseInfluence * DPR;
            if (d2 < r * r) {
              const d = Math.sqrt(d2) || 0.001;
              const ux = dx / d,
                uy = dy / d;
              p.vx += ux * (CONFIG.clickBurst / 100);
              p.vy += uy * (CONFIG.clickBurst / 100);
            }
          }
        });

        // ====== Links between neighbors ======
        function drawLinks() {
          ctx.lineWidth = 1 * DPR;
          ctx.strokeStyle = CONFIG.colorLink;
          for (let i = 0; i < particles.length; i++) {
            for (let j = i + 1; j < particles.length; j++) {
              const a = particles[i],
                b = particles[j];
              const dx = a.x - b.x,
                dy = a.y - b.y;
              const dist = Math.hypot(dx, dy);
              if (dist < CONFIG.linkDist * DPR) {
                const alpha = CONFIG.linkAlpha * (1 - dist / (CONFIG.linkDist * DPR));
                ctx.globalAlpha = alpha;
                ctx.beginPath();
                ctx.moveTo(a.x, a.y);
                ctx.lineTo(b.x, b.y);
                ctx.stroke();
              }
            }
          }
          ctx.globalAlpha = 1;
        }

        // ====== Loop ======
        function loop() {
          ctx.clearRect(0, 0, W, H);

          // Step + draw
          for (let i = 0; i < particles.length; i++) {
            particles[i].step(mouse.x, mouse.y);
          }

          drawLinks();

          for (let i = 0; i < particles.length; i++) {
            particles[i].draw();
          }

          requestAnimationFrame(loop);
        }

        // Init
        resize();
        for (let i = 0; i < 120; i++) particles.push(new Particle()); // seed; va fi ajustat la resize
        computeParticlesCount();
        loop();

      };
    </script>

    <!-- Fonts to support Material Design -->
    <link rel="preconnect" href="https://fonts.googleapis.com" />
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin />
    <link
      rel="stylesheet"
      href="https://fonts.googleapis.com/css2?family=Inter:ital,opsz,wght@0,14..32,100..900;1,14..32,100..900&family=Roboto:ital,wght@0,100;0,300;0,400;0,500;0,700;0,900;1,100;1,300;1,400;1,500;1,700;1,900&display=swap"
    />
    <!-- Icons to support Material Design -->
    <link
      rel="stylesheet"
      href="https://fonts.googleapis.com/icon?family=Material+Icons"
    />
  </head>
  <body>
    <canvas id="bg" style="opacity: 0.5;"></canvas>
    <div id="root"></div>
    <script type="module" src="/src/main.tsx"></script>
  </body>
</html>
